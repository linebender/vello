// SPDX-License-Identifier: Apache-2.0 OR MIT OR Unlicense

// This is "kernel 4" in a 4-kernel pipeline. It renders the commands
// in the per-tile command list to an image.

// Right now, this kernel stores the image in a buffer, but a better
// plan is to use a texture. This is because of limited support.

#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "mem.h"
#include "setup.h"

#define CHUNK_X 2
#define CHUNK_Y 2
#define CHUNK CHUNK_X * CHUNK_Y
#define CHUNK_DX (TILE_WIDTH_PX / CHUNK_X)
#define CHUNK_DY (TILE_HEIGHT_PX / CHUNK_Y)
layout(local_size_x = CHUNK_DX, local_size_y = CHUNK_DY) in;

layout(set = 0, binding = 1) readonly buffer ConfigBuf {
    Config conf;
};

layout(rgba8, set = 0, binding = 2) uniform writeonly image2D image;

layout(r32ui, set = 0, binding = 3) uniform uimage2D winding_lut;

#if GL_EXT_nonuniform_qualifier
layout(rgba8, set = 0, binding = 3) uniform readonly image2D images[];
#else
layout(rgba8, set = 0, binding = 3) uniform readonly image2D images[1];
#endif

#include "ptcl.h"
#include "tile.h"

// Layout of a clip scratch frame:
// Each frame is WIDTH * HEIGHT 32-bit words, then a link reference.

// Link offset and frame size in 32-bit words.
#define CLIP_LINK_OFFSET (TILE_WIDTH_PX * TILE_HEIGHT_PX)
#define CLIP_BUF_SIZE (CLIP_LINK_OFFSET + 1)

#define WINDING_LUT_SIZE 256

shared MallocResult sh_clip_alloc;

// The lookup table is implemented based on the description of Efficient GPU Path Rendering Using Scanline Rasterization,
// Li et al. 2016. The coordinate mapping could potentially use some improvement (since the paper does not mention how
// they derived it), but for now it's implemented verbatim from the paper's description.
// The lookup table is precomputed in piet_gpu::Renderer::make_winding_lut.
uint getLut(vec2 n, float c) {
    // Storing these variables into a temporary helps the compiler to generate code that is capable of instruction-level
    // parallelism, which avoids stalling the pipeline before the sampled bitmasks are actually used.
    uint mask = 0;
    uint signBit = floatBitsToUint(c) & 0x80000000u;
    n = uintBitsToFloat(floatBitsToUint(n) ^ uvec2(signBit));
    c = abs(c);
    uint base = int(signBit) >> 31;
    if (c < 1.) {
        vec2 tex_coord = (0.5 - 0.5 * c) * n + vec2(0.5, 0.5);
        uvec4 tex = imageLoad(winding_lut, ivec2(vec2(WINDING_LUT_SIZE * tex_coord)));
        mask = tex.r;
    }
    return base ^ mask;
}

// Same as getLut, but specialized for n = (0, 1) and uses the distance from top edge instead of center.
// A trick is used in piet_gpu::Renderer::make_winding_lut so that this can be done with arithmetic only.
uint vertLut(float y) {
    uint idx = uint(clamp(y + 0.5 / 32., 0., 1.) * 32.);
    // ~0 << idx, but in a weird way to avoid UB on idx == 32
    // base = idx == 32 ? 1 : 0;
    uint base = idx >> 5;
    // Hopefully all implementation satisfies 0 << 32 == 0 (but this is undefined)
    return (base - 1) << idx;
}

// Allocate a scratch buffer for clipping.
MallocResult alloc_clip_buf(uint link) {
    if (gl_LocalInvocationID.x == 0 && gl_LocalInvocationID.y == 0) {
        MallocResult m = malloc(CLIP_BUF_SIZE * 4);
        if (!m.failed) {
            write_mem(m.alloc, (m.alloc.offset >> 2) + CLIP_LINK_OFFSET, link);
        }
        sh_clip_alloc = m;
    }
    barrier();
    return sh_clip_alloc;
}

vec3 tosRGB(vec3 rgb) {
    bvec3 cutoff = greaterThanEqual(rgb, vec3(0.0031308));
    vec3 below = vec3(12.92)*rgb;
    vec3 above = vec3(1.055)*pow(rgb, vec3(0.41666)) - vec3(0.055);
    return mix(below, above, cutoff);
}

vec3 fromsRGB(vec3 srgb) {
    // Formula from EXT_sRGB.
    bvec3 cutoff = greaterThanEqual(srgb, vec3(0.04045));
    vec3 below = srgb/vec3(12.92);
    vec3 above = pow((srgb + vec3(0.055))/vec3(1.055), vec3(2.4));
    return mix(below, above, cutoff);
}

// unpacksRGB unpacks a color in the sRGB color space to a vec4 in the linear color
// space.
vec4 unpacksRGB(uint srgba) {
    vec4 color = unpackUnorm4x8(srgba).wzyx;
    return vec4(fromsRGB(color.rgb), color.a);
}

// packsRGB packs a color in the linear color space into its 8-bit sRGB equivalent.
uint packsRGB(vec4 rgba) {
    rgba = vec4(tosRGB(rgba.rgb), rgba.a);
    return packUnorm4x8(rgba.wzyx);
}

uvec2 chunk_offset(uint i) {
    return uvec2(i % CHUNK_X * CHUNK_DX, i / CHUNK_X * CHUNK_DY);
}

vec4[CHUNK] fillImage(uvec2 xy, CmdImage cmd_img) {
    vec4 rgba[CHUNK];
    for (uint i = 0; i < CHUNK; i++) {
        ivec2 uv = ivec2(xy + chunk_offset(i)) + cmd_img.offset;
#ifdef ENABLE_IMAGE_INDICES
        vec4 fg_rgba = imageLoad(images[cmd_img.index], uv);
#else
        vec4 fg_rgba = imageLoad(images[0], uv);
#endif
        fg_rgba.rgb = fromsRGB(fg_rgba.rgb);
        rgba[i] = fg_rgba;
    }
    return rgba;
}

void main() {
    if (mem_error != NO_ERROR) {
        return;
    }

    uint tile_ix = gl_WorkGroupID.y * conf.width_in_tiles + gl_WorkGroupID.x;
    Alloc cmd_alloc = slice_mem(conf.ptcl_alloc, tile_ix * PTCL_INITIAL_ALLOC * 2, PTCL_INITIAL_ALLOC);
    CmdRef cmd_ref = CmdRef(cmd_alloc.offset);

    uvec2 xy_uint = uvec2(gl_LocalInvocationID.x + TILE_WIDTH_PX * gl_WorkGroupID.x, gl_LocalInvocationID.y + TILE_HEIGHT_PX * gl_WorkGroupID.y);
    vec2 xy = vec2(xy_uint);
    vec3 rgb[CHUNK];
    uint stencil[CHUNK];
    uint coverage[CHUNK];
    uint stencil_stack[256][CHUNK];
    uint clip_depth = 0;
    uint alpha_stencil_stack[256][CHUNK];
    uint alpha_depth = 0;

    Alloc clip_tos = new_alloc(0, 0);
    for (uint i = 0; i < CHUNK; i++) {
        rgb[i] = vec3(0.0);
#ifdef ENABLE_IMAGE_INDICES
        if (xy_uint.x < 1024 && xy_uint.y < 1024) {
            // rgb[i] = imageLoad(images[gl_WorkGroupID.x / 64], ivec2(xy_uint.x, xy_uint.y + CHUNK_DY * i)/4).rgb;
        }
#endif
        stencil[i] = 0;
    }

    float area[CHUNK];
    while (true) {
        uint tag = Cmd_tag(cmd_alloc, cmd_ref).tag;
        if (tag == Cmd_End) {
            break;
        }
        switch (tag) {
        case Cmd_Stroke:
            // Calculate distance field from all the line segments in this tile.
            CmdStroke stroke = Cmd_Stroke_read(cmd_alloc, cmd_ref);
            TileSegRef tile_seg_ref = TileSegRef(stroke.tile_ref);
            for (uint k = 0; k < CHUNK; k++) {
                coverage[k] = 0;
            }
            do {
                TileSeg seg = TileSeg_read(new_alloc(tile_seg_ref.offset, TileSeg_size), tile_seg_ref);
                float len2 = dot(seg.vector, seg.vector);
                if (len2 > 0.) {
                    // Compute the stroke area with a rectanglar implicit test.
                    float rlen = inversesqrt(len2);
                    float len = rlen * len2;
                    vec2 u = seg.vector * rlen;
                    vec2 n = vec2(-u.y, u.x);
                    for (uint k = 0; k < CHUNK; k++) {
                        if (stencil[k] == ~0u) continue;
                        vec2 my_xy = xy + vec2(chunk_offset(k));
                        vec2 dpos = seg.origin - my_xy - vec2(0.5, 0.5);
                        float kp = dot(dpos, n);
                        uint par = getLut(n, kp + stroke.half_width) ^ getLut(n, kp - stroke.half_width);
                        float ko = dot(dpos, u);
                        uint ortho = getLut(u, ko) ^ getLut(u, ko + len);
                        coverage[k] |= par & ortho;
                    }
                }
                tile_seg_ref = seg.next;
            } while (tile_seg_ref.offset != 0);
            cmd_ref.offset += 4 + CmdStroke_size;
            break;
        case Cmd_Fill:
            CmdFill fill = Cmd_Fill_read(cmd_alloc, cmd_ref);
            for (uint k = 0; k < CHUNK; k++) coverage[k] = (fill.backdrop % 2 == 0 ? 0 : ~0);
            tile_seg_ref = TileSegRef(fill.tile_ref);
            do {
                TileSeg seg = TileSeg_read(new_alloc(tile_seg_ref.offset, TileSeg_size), tile_seg_ref);
                vec2 o = vec2(0.5, 0.5);
                vec2 n = normalize(vec2(-seg.vector.y, seg.vector.x));
                // Make sure that the normal vector points the right side (we want the area to the right of the line).
                // The code below flips n if n.x < 0.
                uint signBit = floatBitsToUint(n.x) & 0x80000000u;
                n = vec2(abs(n.x), uintBitsToFloat(floatBitsToUint(n.y) ^ signBit));
                for (uint k = 0; k < CHUNK; k++) {
                    if (stencil[k] == ~0u) continue;
                    vec2 my_xy = xy + vec2(chunk_offset(k));
                    vec2 start = seg.origin - my_xy;
                    vec2 end = start + seg.vector;
                    // The horizontal ray test is calculated with lookup tables as an AND of three half-planes:
                    // Two of them are used to confine the range of y, and this is implemented using a logically equivalent
                    // method with XOR. While the left edge is already clipped to tile boundary (see path_corase.comp), there
                    // is no equivalent preprocessing performed on the right edge. However this is fine: when combined with the
                    // third half-plane, which corresponds to the line, this will always yield the correct coverage.
                    uint y_range = vertLut(start.y) ^ vertLut(end.y);
                    float c = dot(n, start - o);
                    coverage[k] ^= y_range & getLut(n, c);

                    // Calculate the vertical ray (also called y-edge).
                    coverage[k] ^= vertLut(seg.y_edge - my_xy.y);
                }
                tile_seg_ref = seg.next;
            } while (tile_seg_ref.offset != 0);
            cmd_ref.offset += 4 + CmdFill_size;
            break;
        case Cmd_Solid:
            for (uint k = 0; k < CHUNK; k++) {
                coverage[k] = ~0u;
            }
            cmd_ref.offset += 4;
            break;
        case Cmd_Color:
            CmdColor color = Cmd_Color_read(cmd_alloc, cmd_ref);
            vec4 fg = unpacksRGB(color.rgba_color);
            for (uint k = 0; k < CHUNK; k++) {
                float area = float(bitCount(coverage[k] & ~stencil[k])) / 32.;
                if (fg.a == 1.0) {
                    rgb[k] = rgb[k] + fg.rgb * area;
                    // only update stencil if opaque
                    stencil[k] |= coverage[k];
                } else {
                    vec4 fg_k = fg * area;
                    rgb[k] = rgb[k] * (1.0 - fg_k.a) + fg_k.rgb;
                }
            }
            cmd_ref.offset += 4 + CmdColor_size;
            break;
        case Cmd_Image:
            CmdImage fill_img = Cmd_Image_read(cmd_alloc, cmd_ref);
            vec4 img[CHUNK] = fillImage(xy_uint, fill_img);
            for (uint k = 0; k < CHUNK; k++) {
                float area = float(bitCount(coverage[k] & ~stencil[k])) / 32.;
                vec4 fg_k = img[k] * area;
                rgb[k] = rgb[k] * (1.0 - fg_k.a) + fg_k.rgb;
            }
            cmd_ref.offset += 4 + CmdImage_size;
            break;
        case Cmd_BeginClip:
            for (uint k = 0; k < CHUNK; k++) {
                stencil_stack[clip_depth][k] = stencil[k];
                stencil[k] |= ~coverage[k];
            }
            clip_depth++;
            cmd_ref.offset += 4;
            break;
        case Cmd_EndClip:
            clip_depth--;
            for (uint k = 0; k < CHUNK; k++) {
                stencil[k] = stencil_stack[clip_depth][k];
            }
            cmd_ref.offset += 4;
            break;
        case Cmd_SaveStencil:
            for (uint k = 0; k < CHUNK; k++) {
                alpha_stencil_stack[alpha_depth][k] = stencil[k];
            }
            alpha_depth++;
            cmd_ref.offset += 4;
            break;
        case Cmd_RestoreStencil:
            alpha_depth--;
            for (uint k = 0; k < CHUNK; k++) {
                stencil[k] = alpha_stencil_stack[alpha_depth][k];
            }
            cmd_ref.offset += 4;
            break;
        case Cmd_Jump:
            cmd_ref = CmdRef(Cmd_Jump_read(cmd_alloc, cmd_ref).new_ref);
            cmd_alloc.offset = cmd_ref.offset;
            continue;
        }
    }

    for (uint i = 0; i < CHUNK; i++) {
        imageStore(image, ivec2(xy_uint + chunk_offset(i)), vec4(tosRGB(rgb[i]), 1.0));
    }
}
